+ client: row and col legend
+ client: Socket Timeout Exception handling
+ client: enqueue -> refactor
+ client: pawnTransformation chooser
+ rollback button support
+ constructor bar:
    + кнопка удаления фигур с доски
    + разрешить перемещение фигур внутри доски в любую точку
    + drag and drop?
    + continue game
+ create new game -> ../game/new?mode=selectedMove&side=selectedSide
+ CONSTRUCTOR mode refactoring: (ну там табличку отдельную завести со своим форматом и все такое)
+ client: opponent move listener

+ синхронизация ч.1
    + fireBotMove: make async with delay
    + botService.cancelByRollback
    + game cache
    + GameResult: val game, val T
    + gameService.applyPlayerMove/applyBotMove
    + applyMove: check moverSide
    + нельзя завязываться на gameCache.asMap(), оно работает не как ConcurrentHashMap(судя по всему блочится вся мапа при put/compute операциях)
    + gameService.listenChanges: добавить проверки
    + избавиться от @InjectGame etc
    + SessionManager:
        + create
        + cleanSyncMap
    + флажок isProcessing в private applyMove (чтобы следующий applyMove не вставал в очередь а падал с ошибкой)
            + решено с помощью tryLock
    + gameService -> fireBotMove
    + проблема одновременного применения applyMove:
            + слать expectedPosition от клиента для playerMove
            + разрулить на уровне botService для botMove

+ client: поменять API под новые запросы
+ для PVP режима проверять: side = pieceFrom.side

- move cost support:
    - moves tree
    - available moves tree viewer support
    - ...

- тесты для Chessboard, MovesProvider
- client: для SINGLE режима разрешить ходить всегда без изменения chessboardView.state.side
- IEventsMulticaster
- onServerRunning: fire bot move
- client: rotation fix
- MoveDTO: IMove, PointDTO: IPoint, ChessUtils -> shared, MovesProvider -> shared
- про rollback-е теряется инфа о lastMove. fix it
- constructor: validate board
- client: ListenOpponentChangesTask -> stop/start if visible changed
- client:  ListenOpponentChangesTask -> @SuppressLint("StaticFieldLeak")

- синхронизация ч.2
    - слать clientPosition и сверять его с gamePosition на сервере
        + server
        - client:
            - DebugCheckChessboardState?
            - на каждый запрос сервер должен присылать актуальную позицию
            - клиент должен уходить на релоад (continue game), если:
                - на клиенте не сошлись позиции
                - сервер прислал ошибку рассинхрона

    - считать хэш для chessboard и сравнивать с каждым запросом
    - client: сделать защиту от слишком частых запросов на сервер

- client: legend refactoring    (LayoutInflater)
- client: drag and drop in chessboard view
- client: надо как-то победить долгий первый вызов ретрофита