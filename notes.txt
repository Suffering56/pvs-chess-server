+ client: row and col legend
+ client: Socket Timeout Exception handling
+ client: enqueue -> refactor
+ client: pawnTransformation chooser
+ rollback button support
+ constructor bar:
    + кнопка удаления фигур с доски
    + разрешить перемещение фигур внутри доски в любую точку
    + drag and drop?
    + continue game
+ create new game -> ../game/new?mode=selectedMove&side=selectedSide
+ CONSTRUCTOR mode refactoring: (ну там табличку отдельную завести со своим форматом и все такое)
+ client: opponent move listener

+ синхронизация ч.1
    + fireBotMove: make async with delay
    + botService.cancelByRollback
    + game cache
    + GameResult: val game, val T
    + gameService.applyPlayerMove/applyBotMove
    + applyMove: check moverSide
    + нельзя завязываться на gameCache.asMap(), оно работает не как ConcurrentHashMap(судя по всему блочится вся мапа при put/compute операциях)
    + gameService.listenChanges: добавить проверки
    + избавиться от @InjectGame etc
    + SessionManager:
        + create
        + cleanSyncMap
    + флажок isProcessing в private applyMove (чтобы следующий applyMove не вставал в очередь а падал с ошибкой)
            + решено с помощью tryLock
    + gameService -> fireBotMove
    + проблема одновременного применения applyMove:
            + слать expectedPosition от клиента для playerMove
            + разрулить на уровне botService для botMove

+ client: поменять API под новые запросы
+ для PVP режима проверять: side = pieceFrom.side
- move cache
- mutable chessboard bot move selector:
    - actualize chessboard


- chessboard row cache: использовать в версии с immutable доской
    - количество возможных комбинаций строк равно количеству размещений с повторениями 13(типов фигур + null) по 8(размер доски)
    - оно равно 815_730_721:
        - на самом деле это число меньше, т.к. количество повторений ограничено не 8-ю (кроме пешек)
        - так же много комбинаций будут недостижимы благодаря другим ограничениям игры
        - а поскольку расчет требует клонов одной и той же доски, то все это дело будет великолепно кэшироваться (like ProtoMessageKey=obj+hash)
    - предположим что каждая такая строка это Array<Piece?> из 8 элементов. в heap это займет 16+8*4(вес enum, который можно заменить на byte)
    - итого: 48 байт на каждую строку, либо 24, если использовать byte вместо enum

- flame graph

- move cost support:
    - moves tree
    - available moves tree viewer support
    - ...

- game: longCastlingAvailable можно объединить с shortCastlingAvailable и хранить все в битовых флагах
- тесты для Chessboard, MovesProvider
- client: для SINGLE режима разрешить ходить всегда без изменения chessboardView.state.side
- IEventsMulticaster
- onServerRunning: fire bot move
- client: rotation fix
- MoveDTO: IMove, PointDTO: IPoint, ChessUtils -> shared, MovesProvider -> shared
- про rollback-е теряется инфа о lastMove. fix it
- constructor: validate board
- client: ListenOpponentChangesTask -> stop/start if visible changed
- client:  ListenOpponentChangesTask -> @SuppressLint("StaticFieldLeak")

- синхронизация ч.2
    - слать clientPosition и сверять его с gamePosition на сервере
        + server
        - client:
            - DebugCheckChessboardState?
            - на каждый запрос сервер должен присылать актуальную позицию
            - клиент должен уходить на релоад (continue game), если:
                - на клиенте не сошлись позиции
                - сервер прислал ошибку рассинхрона

    - считать хэш для chessboard и сравнивать с каждым запросом
    - client: сделать защиту от слишком частых запросов на сервер

- client: legend refactoring    (LayoutInflater)
- client: drag and drop in chessboard view
- client: надо как-то победить долгий первый вызов ретрофита